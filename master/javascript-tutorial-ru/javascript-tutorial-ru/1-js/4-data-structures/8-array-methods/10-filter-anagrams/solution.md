# Решение

Чтобы обнаружить анаграммы, разобьём каждое слово на буквы и отсортируем их. В отсортированном по буквам виде все анаграммы одинаковы.

Например:

```
воз, зов -> взо
киборг, гробик -> бгикор
...
```

По такой последовательности будем делать массив уникальным.

Для этого воспользуемся вспомогательным объектом, в который будем записывать слова по отсортированному ключу:

```js run
function aclean(arr) {
  // этот объект будем использовать для уникальности
  var obj = {};

  for (var i = 0; i < arr.length; i++) {
    // разбить строку на буквы, отсортировать и слить обратно
*!*
    var sorted = arr[i].toLowerCase().split('').sort().join(''); // (*)
*/!*

    obj[sorted] = arr[i]; // сохраняет только одно значение с таким ключом
  }

  var result = [];

  // теперь в obj находится для каждого ключа ровно одно значение
  for (var key in obj) result.push(obj[key]);

  return result;
}

var arr = ["воз", "киборг", "корсет", "ЗОВ", "гробик", "костер", "сектор"];

alert( aclean(arr) );
```

Приведение слова к  сортированному по буквам виду осуществляется цепочкой вызовов в строке `(*)`.

Для удобства комментирования разобьём её на несколько строк (JavaScript это позволяет):

```js
var sorted = arr[i] // ЗОВ
  .toLowerCase() // зов
  .split('') // ['з','о','в']
  .sort() // ['в','з','о']
  .join(''); // взо
```

Получится, что два разных слова `'ЗОВ'` и `'воз'` получат одинаковую отсортированную форму `'взо'`.

Следующая строка:

```js
obj[sorted] = arr[i];
```

В объект `obj` будет записано сначала первое из слов `obj['взо'] = "воз"`, а затем `obj['взо'] = 'ЗОВ'`.

Обратите внимание, ключ -- отсортирован, а само слово -- в исходной форме, чтобы можно было потом получить его из объекта.

Вторая запись по тому же ключу перезапишет первую, то есть в объекте останется ровно одно слово с таким набором букв.

