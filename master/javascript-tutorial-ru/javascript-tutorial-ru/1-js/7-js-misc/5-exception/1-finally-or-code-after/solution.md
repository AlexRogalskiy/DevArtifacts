Разница в поведении станет очевидной, если рассмотреть код внутри функции.

Поведение будет различным, если управление каким-то образом выпрыгнет из `try..catch`.

Например, `finally` сработает после `return`, но до передачи управления внешнему коду:

```js
function f() {
  try {
    ...
*!*
    return result;
*/!*
  } catch (e) {
    ...
  } finally {
    очистить ресурсы
  }
}
```

Или же управление может выпрыгнуть из-за `throw`:

```js
function f() {
  try {
    ...

  } catch (e) {
    ...
    if(не умею обрабатывать эту ошибку) {
*!*
      throw e;
*/!*
    }

  } finally {
    очистить ресурсы
  }
}
```

В этих случаях именно `finally` гарантирует выполнение кода до окончания работы `f`, просто код не будет вызван.
