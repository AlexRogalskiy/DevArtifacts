# Свои классы на прототипах

Используем ту же структуру, что JavaScript использует внутри себя, для объявления своих классов.

[cut]

## Обычный конструктор

Вспомним, как мы объявляли классы ранее.

Например, этот код задаёт класс `Animal` в функциональном стиле, без всяких прототипов:

```js run
function Animal(name) {
  this.speed = 0;
  this.name = name;

  this.run = function(speed) {
    this.speed += speed;
    alert( this.name + ' бежит, скорость ' + this.speed );
  };

  this.stop = function() {
    this.speed = 0;
    alert( this.name + ' стоит' );
  };
};

var animal = new Animal('Зверь');

alert( animal.speed ); // 0, начальная скорость
animal.run(3); // Зверь бежит, скорость 3
animal.run(10); // Зверь бежит, скорость 13
animal.stop(); // Зверь стоит
```

## Класс через прототип

А теперь создадим аналогичный класс, используя прототипы, наподобие того, как сделаны классы `Object`, `Date` и остальные.

Чтобы объявить свой класс, нужно:

1. Объявить функцию-конструктор.
2. Записать методы и свойства, нужные всем объектам класса, в `prototype`.

Опишем класс `Animal`:

```js run
// конструктор
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

// методы в прототипе
Animal.prototype.run = function(speed) {
  this.speed += speed;
  alert( this.name + ' бежит, скорость ' + this.speed );
};

Animal.prototype.stop = function() {
  this.speed = 0;
  alert( this.name + ' стоит' );
};

var animal = new Animal('Зверь');

alert( animal.speed ); // 0, свойство взято из прототипа
animal.run(5); // Зверь бежит, скорость 5
animal.run(5); // Зверь бежит, скорость 10
animal.stop(); // Зверь стоит
```

В объекте `animal` будут храниться свойства конкретного экземпляра: `name` и `speed`, а общие методы -- в прототипе.

Совершенно такой же подход, как и для встроенных классов в JavaScript.

## Сравнение

Чем такое задание класса лучше и хуже функционального стиля?

```compare
+ Функциональный стиль записывает в каждый объект и свойства и методы, а прототипный -- только свойства. Поэтому прототипный стиль -- быстрее и экономнее по памяти.
- При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором.
```

Таким образом, прототипный стиль -- быстрее и экономнее, но немного  менее удобен.

К примеру, есть у нас приватное свойство `name` и метод `sayHi` в функциональном стиле ООП:

```js run
function Animal(name) {
  this.sayHi = function() {
*!*
    alert( name );
*/!*
  };
}

var animal = new Animal("Зверь");
animal.sayHi(); // Зверь
```

При задании методов в прототипе мы не сможем её так оставить, ведь методы находятся *вне* конструктора, у них нет общей области видимости, поэтому приходится записывать `name` в сам объект, обозначив его как защищённое:

```js run
function Animal(name) {
*!*
  this._name = name;
*/!*
}

Animal.prototype.sayHi = function() {
*!*
  alert( this._name );
*/!*
}

var animal = new Animal("Зверь");
animal.sayHi(); // Зверь
```

Впрочем, недостаток этот -- довольно условный. Ведь при наследовании в функциональном стиле также пришлось бы писать `this._name`, чтобы потомок получил доступ к этому значению.
