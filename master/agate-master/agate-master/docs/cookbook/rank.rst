====
Rank
====

There are many ways to rank a sequence of values. agate strives to find a balance between simple, intuitive ranking and flexibility when you need it.

Competition rank
================

The basic rank supported by agate is standard "competition ranking". In this model the values :code:`[3, 4, 4, 5]` would be ranked :code:`[1, 2, 2, 4]`. You can apply competition ranking using the :class:`.Rank` computation:

.. code-block:: python

    new_table = table.compute([
        ('rank', agate.Rank('value'))
    ])

Rank descending
===============

Descending competition ranking is specified using the :code:`reverse` argument.

.. code-block:: python

    new_table = table.compute([
        ('rank', agate.Rank('value', reverse=True))
    ])

Rank change
===========

You can compute the change from one rank to another by combining the :class:`.Rank` and :class:`.Change` computations:

.. code-block:: python

    new_table = table.compute([
        ('rank2014', agate.Rank('value2014')),
        ('rank2015', agate.Rank('value2015'))
    ])

    new_table2 = new_table.compute([
        ('rank_change', agate.Change('rank2014', 'rank2015'))
    ])

Percentile rank
===============

"Percentile rank" is a bit of a misnomer. Really, this is the percentile in which each value in a column is located. This column can be computed for your data using the :class:`.PercentileRank` computation:

.. code-block:: Python

    new_table = table.compute([
        ('percentile_rank', agate.PercentileRank('value'))
    ])

Note that there is no entirely standard method for computing percentiles. The percentiles computed in this manner may not agree precisely with those generated by other software. See the :class:`.Percentiles` class documentation for implementation details.
