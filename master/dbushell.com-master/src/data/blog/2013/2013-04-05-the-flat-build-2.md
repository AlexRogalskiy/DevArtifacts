---
date: 2013-04-05 10:26:18+00:00
excerpt: None
slug: the-flat-build-2
template: single.html
title: The Flat Build (2)
---

My article [The Flat Build](/2013/03/18/the-flat-build/) was a slow burner but it has picked up steam recently and for the first time in like, forever, I'm building a pre-designed* website without having design influence. This has proven to be a good opportunity to refine and expand upon my flat build workflow (again).

I'm aware I'm reinventing more than a few wheels here. This project has always been about starting from the ground up and questioning every choice.

<p class="p--small">* Yeah, I'm a big advocate for agile "decide in the browser" web design/dev, but I have to admit that a beautifully maintained PSD deliverable still feels like Christmas.</p>




## Boilerplate


I've always maintained a personal set of HTML & CSS files to use as a starting point for any build. Mostly good practices, general preferences, and stuff I forget like the favicon.

<p class="b-post__image">![Icon Slate favicon app](/images/2013/04/iconslateapp.png)</p>

This practice has never actually helped me _remember_ the favicon — you have to love boilerplate deployment — but after catching up with [Chris Coyier's screencast](http://css-tricks.com/video-screencasts/122-the-state-of-favicons/) I have a new found love. I'm currently writing the favicon-first manifesto…


## Repository


I use Git as source control for everything. This includes my boilerplate which I can evolve and fork for new projects. Starting a new build requires these steps:


1. Initialise a new Git repo
2. Merge in my boilerplate code
3. Run `npm install` to pull in dependencies (basically [Grunt](http://gruntjs.com/) + tasks)


[Sublime Text 2](http://www.sublimetext.com/2) and [iTerm](http://www.iterm2.com/) (with[ oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)) are my apps of choice for code management.

<p class="b-post__image">![Sublime and iTerm](/images/2013/04/sublimeproject.png)</p>


<p class="p--small">And yes, I work on the master branch and name my devices after monkeys.</p>

As you can see my project directory structure looks like this:


* `build/`
* `src/`
* `tasks/`
* `templates/`
* `Gruntfile.js`
* `package.json`
* `README.md`


The `build` directory is generated by Grunt and never committed to Git. It contains the final static website with no outside dependencies. I can view it in the browser, archive and email to a client, toss on a server, or just delete and rebuild it entirely for a laugh (that novelty wears off).

The `src` directory contains the actual editable source and original assets; Sass, JavaScript, SVG, web fonts etc. The `templates` directory contains HTML (I should probably move this into `src` for consistency). My [HTML Grunt task](https://gist.github.com/dbushell/5317948) — new and improved* — lets me separate HTML includes and reference relative assets or paths. All without server-side scripting.

<p class="p--small">* use at your own risk.</p>

The basic principle here is to keep a **single source** for all working assets. If that isn't the final output — e.g. Sass or un-minified JavaScript — the output should get compiled automatically. Similarly, I don't want to manually maintain PNG fallbacks for vector graphics if they can be built from source. The whole set up is complex but the act of building is simplified.

The complete set of build tasks can be quite slow so I need to build individual components as and when they are modified.


## Who watches the watchmen?


I've been using [Compass](http://compass-style.org/) for a long time to generate CSS. With pre-processors you get a nice command line programme to watch for changes and automatically generate plain CSS output. This alleviates the burden that an extra step adds.

With my new practice of separation between source and build I need a more powerful watcher. [Grunt watch](https://github.com/gruntjs/grunt-contrib-watch) comes to the rescue. For each requirement I instruct it to watch a set of files and then perform a specific task. HTML is edited? Rebuild it. CSS changes? Recompile it. SVGs are modified? Optimise and create raster fallbacks (OK, [I haven't perfected that yet](https://twitter.com/dbushell/status/318733510674350081/)).

Whenever I'm working on a project I just run `grunt watch` and let it go.


## Next step


Like I said, none of this is particular ground breaking but I'm learning a huge amount by starting from scratch. I could jump straight into an existing solution like [Yeoman](http://yeoman.io/) but I'd never really understand the "why" behind the process. My quest is [automation](/2013/03/12/automation/) and I'm already making life easier. Even with the less than optimal set of tasks I've hacked together.

I've written a lot about **facilitating** the build process but not the actual practice of writing HTML, CSS, and JavaScript itself. The most time consuming thing of all. I'll follow up on that soon, for now read my [5 Tips for Responsive Builds](/2013/01/01/five-tips-for-responsive-builds/) and be sure to read Dave Rupert's excellent article on [Responsive Deliverables](http://daverupert.com/2013/04/responsive-deliverables/).
